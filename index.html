<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scacchi by Dr. F. Marinuzzi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            min-h-screen display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .menu-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 3rem;
            border-radius: 24px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
            width: 100%;
        }
        
        .game-container {
            display: flex;
            gap: 2rem;
            max-width: 1400px;
            width: 100%;
        }
        
        .board-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .ai-section {
            width: 350px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        h1 {
            font-size: 3.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        
        .subtitle {
            color: #d1d5db;
            margin-bottom: 2rem;
        }
        
        .difficulty-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        
        .btn {
            width: 100%;
            padding: 1rem 1.5rem;
            margin: 0.5rem 0;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .btn:hover {
            transform: scale(1.02);
        }
        
        .btn-easy {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
        }
        
        .btn-medium {
            background: linear-gradient(45deg, #f59e0b, #ea580c);
            color: white;
        }
        
        .btn-hard {
            background: linear-gradient(45deg, #ef4444, #ec4899);
            color: white;
        }
        
        .btn-custom {
            background: linear-gradient(45deg, #8b5cf6, #6366f1);
            color: white;
        }
        
        .btn-surrender {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.2s;
            margin-left: 1rem;
        }
        
        .btn-surrender:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }
        
        .btn-reset {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 1rem;
            transition: all 0.2s;
        }
        
        .btn-reset:hover {
            transform: scale(1.02);
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .header-left {
            display: flex;
            align-items: center;
        }
        
        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .players {
            display: flex;
            gap: 1rem;
        }
        
        .player {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .player.active {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        
        .player-white {
            background: linear-gradient(45deg, #dbeafe, #ffffff);
            color: #1e40af;
        }
        
        .player-black {
            background: linear-gradient(45deg, #374151, #111827);
            color: white;
        }
        
        .player.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #9ca3af;
        }
        
        .check-alert {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .board {
            background: #f0d9b5;
            padding: 1.5rem;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            border: 3px solid #8b7355;
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 2px solid #8b7355;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            font-weight: bold;
            line-height: 1;
        }
        
        .square.light {
            background: #f0d9b5;
        }
        
        .square.dark {
            background: #b58863;
        }
        
        .square:hover {
            filter: brightness(1.1);
        }
        
        .square.selected {
            box-shadow: inset 0 0 0 4px #3b82f6;
            background: rgba(59, 130, 246, 0.2) !important;
        }
        
        .square.valid-move {
            box-shadow: inset 0 0 0 3px #10b981;
        }
        
        .square.valid-move::before {
            content: '';
            position: absolute;
            inset: 12px;
            background: rgba(16, 185, 129, 0.4);
            border-radius: 50%;
            z-index: 1;
        }
        
        .square.last-move {
            box-shadow: inset 0 0 0 4px #fbbf24;
            background: rgba(251, 191, 36, 0.3) !important;
            animation: glow 2s infinite;
        }
        
        .square.animating {
            animation: bounce 0.3s ease;
            z-index: 10;
        }
        
        .piece-white {
            color: #ffffff;
            text-shadow: 
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000,
                0 0 12px rgba(0, 0, 0, 0.9);
        }
        
        .piece-black {
            color: #000000;
            text-shadow: 
                -2px -2px 0 #fff,
                2px -2px 0 #fff,
                -2px 2px 0 #fff,
                2px 2px 0 #fff,
                0 0 12px rgba(255, 255, 255, 0.9);
        }
        
        @keyframes glow {
            0%, 100% { 
                box-shadow: inset 0 0 0 4px #fbbf24;
            }
            50% { 
                box-shadow: inset 0 0 0 4px #fbbf24, 0 0 20px rgba(251, 191, 36, 0.6);
            }
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .captured-pieces {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .captured-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            flex: 1;
        }
        
        .captured-title {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .captured-list {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }
        
        .captured-piece {
            font-size: 1.125rem;
        }
        
        .promotion-dialog {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .promotion-content {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        
        .promotion-title {
            color: #374151;
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        
        .promotion-pieces {
            display: flex;
            gap: 1rem;
        }
        
        .promotion-btn {
            width: 4rem;
            height: 4rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .promotion-btn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }
        
        .game-over {
            text-align: center;
            margin-top: 1.5rem;
        }
        
        .game-over-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        
        .win-text {
            background: linear-gradient(45deg, #60a5fa, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .lose-text {
            background: linear-gradient(45deg, #9ca3af, #6b7280);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .draw-text {
            color: #fbbf24;
        }
        
        .ai-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .ai-title {
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .difficulty-badge {
            margin-left: auto;
            font-size: 0.875rem;
            color: #9ca3af;
            text-transform: capitalize;
        }
        
        .ai-thoughts {
            max-height: 600px;
            overflow-y: auto;
        }
        
        .ai-thinking {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .thinking-text {
            color: #93c5fd;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(30, 58, 138, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            animation: pulse 1s infinite;
        }
        
        .progress-label {
            font-size: 0.75rem;
            color: #93c5fd;
            margin-top: 0.25rem;
        }
        
        .thought {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            transition: all 0.3s;
        }
        
        .thought-text {
            color: #d1d5db;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .thought-meta {
            color: #6b7280;
            font-size: 0.75rem;
        }
        
        .no-thoughts {
            color: #6b7280;
            text-align: center;
            padding: 2rem;
        }
        
        .hidden {
            display: none;
        }
        
        .show-menu {
            display: flex;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
        }
        
        .show-game {
            display: flex;
            min-height: 100vh;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div id="app" class="container"></div>

    <script>
        // Costanti globali
        const PIECES = {
            PAWN: 'pawn',
            ROOK: 'rook', 
            KNIGHT: 'knight',
            BISHOP: 'bishop',
            QUEEN: 'queen',
            KING: 'king'
        };

        const PIECE_VALUES = {
            [PIECES.PAWN]: 100,
            [PIECES.ROOK]: 500,
            [PIECES.KNIGHT]: 300,
            [PIECES.BISHOP]: 300,
            [PIECES.QUEEN]: 900,
            [PIECES.KING]: 10000
        };

        const PIECE_SYMBOLS = {
            white: {
                [PIECES.PAWN]: '♙',
                [PIECES.ROOK]: '♖',
                [PIECES.KNIGHT]: '♘',
                [PIECES.BISHOP]: '♗',
                [PIECES.QUEEN]: '♕',
                [PIECES.KING]: '♔'
            },
            black: {
                [PIECES.PAWN]: '♟',
                [PIECES.ROOK]: '♜',
                [PIECES.KNIGHT]: '♞',
                [PIECES.BISHOP]: '♝',
                [PIECES.QUEEN]: '♛',
                [PIECES.KING]: '♚'
            }
        };

        // Stato del gioco
        let game = {
            mode: 'menu',
            board: [],
            currentPlayer: 'white',
            winner: null,
            difficulty: 'medium',
            customDepth: null,
            isAIThinking: false,
            aiThoughts: [],
            selectedPiece: null,
            validMoves: [],
            capturedPieces: { white: [], black: [] },
            lastMove: null,
            animatingPieces: new Set(),
            moveHistory: [],
            isInCheck: false,
            promotionDialog: null
        };

        // Funzioni di base
        function initializeBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            for (let col = 0; col < 8; col++) {
                board[1][col] = { type: PIECES.PAWN, color: 'black' };
                board[6][col] = { type: PIECES.PAWN, color: 'white' };
            }
            
            const backRank = [PIECES.ROOK, PIECES.KNIGHT, PIECES.BISHOP, PIECES.QUEEN, PIECES.KING, PIECES.BISHOP, PIECES.KNIGHT, PIECES.ROOK];
            for (let col = 0; col < 8; col++) {
                board[0][col] = { type: backRank[col], color: 'black' };
                board[7][col] = { type: backRank[col], color: 'white' };
            }
            
            return board;
        }

        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function findKing(board, color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === PIECES.KING && piece.color === color) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        function isKingInCheck(board, color) {
            const kingPos = findKing(board, color);
            if (!kingPos) return false;
            
            const enemyColor = color === 'white' ? 'black' : 'white';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === enemyColor) {
                        const moves = getPieceMoves(board, row, col, piece, false);
                        if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Mosse dei pezzi
        function getPawnMoves(board, row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            const newRow = row + direction;
            if (isValidPosition(newRow, col) && !board[newRow][col]) {
                moves.push({ row: newRow, col });
                
                if (row === startRow && !board[newRow + direction][col]) {
                    moves.push({ row: newRow + direction, col });
                }
            }
            
            for (const dc of [-1, 1]) {
                const captureRow = row + direction;
                const captureCol = col + dc;
                if (isValidPosition(captureRow, captureCol)) {
                    const target = board[captureRow][captureCol];
                    if (target && target.color !== color) {
                        moves.push({ row: captureRow, col: captureCol });
                    }
                }
            }
            
            return moves;
        }

        function getRookMoves(board, row, col, color) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            return moves;
        }

        function getKnightMoves(board, row, col, color) {
            const moves = [];
            const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
            
            for (const [dr, dc] of knightMoves) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isValidPosition(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            return moves;
        }

        function getBishopMoves(board, row, col, color) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            return moves;
        }

        function getQueenMoves(board, row, col, color) {
            return [...getRookMoves(board, row, col, color), ...getBishopMoves(board, row, col, color)];
        }

        function getKingMoves(board, row, col, color) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isValidPosition(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            return moves;
        }

        function getPieceMoves(board, row, col, piece, checkForCheck = true) {
            if (!piece) return [];
            
            let moves = [];
            
            switch (piece.type) {
                case PIECES.PAWN:
                    moves = getPawnMoves(board, row, col, piece.color);
                    break;
                case PIECES.ROOK:
                    moves = getRookMoves(board, row, col, piece.color);
                    break;
                case PIECES.KNIGHT:
                    moves = getKnightMoves(board, row, col, piece.color);
                    break;
                case PIECES.BISHOP:
                    moves = getBishopMoves(board, row, col, piece.color);
                    break;
                case PIECES.QUEEN:
                    moves = getQueenMoves(board, row, col, piece.color);
                    break;
                case PIECES.KING:
                    moves = getKingMoves(board, row, col, piece.color);
                    break;
            }
            
            if (checkForCheck) {
                moves = moves.filter(move => {
                    const testBoard = simulateMove(board, row, col, move.row, move.col);
                    return !isKingInCheck(testBoard, piece.color);
                });
            }
            
            return moves;
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol) {
            const newBoard = board.map(row => [...row]);
            const piece = newBoard[fromRow][fromCol];
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;
            return newBoard;
        }

        function executeMove(board, fromRow, fromCol, toRow, toCol, moveInfo = null) {
            const newBoard = board.map(row => [...row]);
            const piece = newBoard[fromRow][fromCol];
            const capturedPiece = newBoard[toRow][toCol];
            
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;
            
            if (piece.type === PIECES.PAWN) {
                const promotionRow = piece.color === 'white' ? 0 : 7;
                if (toRow === promotionRow) {
                    const promotionPiece = moveInfo?.promotionPiece || PIECES.QUEEN;
                    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color };
                }
            }
            
            return { newBoard, capturedPiece };
        }

        function getAllValidMoves(board, color) {
            const moves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const pieceMoves = getPieceMoves(board, row, col, piece);
                        for (const move of pieceMoves) {
                            moves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                piece
                            });
                        }
                    }
                }
            }
            return moves;
        }

        // IA
        function evaluatePosition(board) {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        let pieceValue = PIECE_VALUES[piece.type];
                        
                        if (piece.color === 'black') {
                            score += pieceValue;
                        } else {
                            score -= pieceValue;
                        }
                    }
                }
            }
            
            return score;
        }

        function alphaBeta(board, depth, alpha, beta, maximizingPlayer, color) {
            if (depth === 0) {
                return { score: evaluatePosition(board), move: null };
            }
            
            const moves = getAllValidMoves(board, color);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, color)) {
                    return { score: maximizingPlayer ? -10000 : 10000, move: null };
                } else {
                    return { score: 0, move: null };
                }
            }
            
            let bestMove = null;
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const { newBoard } = executeMove(board, move.fromRow, move.fromCol, move.toRow, move.toCol, move);
                    const evaluation = alphaBeta(newBoard, depth - 1, alpha, beta, false, 'white');
                    
                    if (evaluation.score > maxEval) {
                        maxEval = evaluation.score;
                        bestMove = move;
                    }
                    
                    alpha = Math.max(alpha, evaluation.score);
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const { newBoard } = executeMove(board, move.fromRow, move.fromCol, move.toRow, move.toCol, move);
                    const evaluation = alphaBeta(newBoard, depth - 1, alpha, beta, true, 'black');
                    
                    if (evaluation.score < minEval) {
                        minEval = evaluation.score;
                        bestMove = move;
                    }
                    
                    beta = Math.min(beta, evaluation.score);
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        function findBestMove(board, depth) {
            const result = alphaBeta(board, depth, -Infinity, Infinity, true, 'black');
            return result.move;
        }

        function checkGameEnd(board, color) {
            const moves = getAllValidMoves(board, color);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, color)) {
                    return color === 'white' ? 'black' : 'white';
                } else {
                    return 'draw';
                }
            }
            return null;
        }

        // Event handlers
        function handleSquareClick(row, col) {
            if (game.mode !== 'playing' || game.currentPlayer !== 'white' || game.isAIThinking) {
                return;
            }
            
            const piece = game.board[row][col];
            
            if (game.selectedPiece) {
                const validMove = game.validMoves.find(m => m.row === row && m.col === col);
                
                if (validMove) {
                    const movingPiece = game.board[game.selectedPiece.row][game.selectedPiece.col];
                    const isPromotion = movingPiece && movingPiece.type === PIECES.PAWN && 
                                       movingPiece.color === 'white' && row === 0;
                    
                    if (isPromotion) {
                        game.promotionDialog = {
                            fromRow: game.selectedPiece.row,
                            fromCol: game.selectedPiece.col,
                            toRow: row,
                            toCol: col,
                            validMove
                        };
                        updateDisplay();
                        return;
                    }
                    
                    makeMove(game.selectedPiece.row, game.selectedPiece.col, row, col, validMove);
                } else {
                    selectPiece(row, col, piece);
                }
            } else {
                selectPiece(row, col, piece);
            }
        }

        function selectPiece(row, col, piece) {
            if (!piece || piece.color !== game.currentPlayer) {
                game.selectedPiece = null;
                game.validMoves = [];
                updateDisplay();
                return;
            }
            
            const moves = getPieceMoves(game.board, row, col, piece);
            game.selectedPiece = { row, col };
            game.validMoves = moves;
            updateDisplay();
        }

        function makeMove(fromRow, fromCol, toRow, toCol, moveInfo, promotionPiece = null) {
            const moveInfoWithPromotion = promotionPiece ? { ...moveInfo, promotionPiece } : moveInfo;
            
            const { newBoard, capturedPiece } = executeMove(
                game.board, fromRow, fromCol, toRow, toCol, moveInfoWithPromotion
            );
            
            const pieceId = `${fromRow}-${fromCol}`;
            game.animatingPieces.add(pieceId);
            
            game.board = newBoard;
            game.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            
            if (capturedPiece) {
                if (game.currentPlayer === 'white') {
                    game.capturedPieces.black.push(capturedPiece);
                } else {
                    game.capturedPieces.white.push(capturedPiece);
                }
            }
            
            setTimeout(() => {
                game.animatingPieces.delete(pieceId);
                updateDisplay();
            }, 300);
            
            const nextPlayer = game.currentPlayer === 'white' ? 'black' : 'white';
            game.isInCheck = isKingInCheck(newBoard, nextPlayer);
            
            const gameEnd = checkGameEnd(newBoard, nextPlayer);
            if (gameEnd) {
                game.winner = gameEnd;
                game.mode = 'gameOver';
            } else {
                game.currentPlayer = nextPlayer;
            }
            
            game.selectedPiece = null;
            game.validMoves = [];
            game.promotionDialog = null;
            
            updateDisplay();
            
            if (game.currentPlayer === 'black' && game.mode === 'playing') {
                setTimeout(makeAIMove, 500);
            }
        }

        async function makeAIMove() {
            game.isAIThinking = true;
            game.aiThoughts = [];
            updateDisplay();

            await new Promise(resolve => setTimeout(resolve, 500));

            game.aiThoughts.push({
                text: "Analizzando tutte le mosse possibili...",
                round: Math.floor(game.moveHistory.length / 2)
            });
            updateDisplay();

            await new Promise(resolve => setTimeout(resolve, 300));

            let searchDepth;
            if (game.difficulty === 'custom') {
                searchDepth = game.customDepth;
            } else {
                switch (game.difficulty) {
                    case 'easy': searchDepth = 2; break;
                    case 'medium': searchDepth = 4; break;
                    case 'hard': searchDepth = 6; break;
                    default: searchDepth = 4;
                }
            }

            game.aiThoughts.push({
                text: `Analisi a ${searchDepth} livelli di profondità...`,
                round: Math.floor(game.moveHistory.length / 2)
            });
            updateDisplay();

            const startTime = Date.now();
            const bestMove = findBestMove(game.board, searchDepth);
            const endTime = Date.now();

            if (!bestMove) {
                game.winner = 'white';
                game.mode = 'gameOver';
                updateDisplay();
                return;
            }

            game.aiThoughts.push({
                text: `Mossa trovata in ${((endTime - startTime) / 1000).toFixed(1)}s`,
                round: Math.floor(game.moveHistory.length / 2)
            });
            updateDisplay();

            await new Promise(resolve => setTimeout(resolve, 300));

            makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol, 
                    { ...bestMove, promotionPiece: PIECES.QUEEN });

            game.isAIThinking = false;
            updateDisplay();
        }

        function surrenderGame() {
            if (game.mode !== 'playing') return;
            
            if (confirm('Sei sicuro di voler abbandonare la partita?')) {
                game.winner = 'black';
                game.mode = 'gameOver';
                game.aiThoughts.push({
                    text: "Il giocatore ha abbandonato la partita! L'IA vince!",
                    round: Math.floor(game.moveHistory.length / 2)
                });
                updateDisplay();
            }
        }

        function executePromotionMove(pieceType) {
            if (!game.promotionDialog) return;
            
            const dialog = game.promotionDialog;
            makeMove(dialog.fromRow, dialog.fromCol, dialog.toRow, dialog.toCol, dialog.validMove, pieceType);
        }

        function startGame(difficulty, customDepth = null) {
            game.difficulty = difficulty;
            game.customDepth = customDepth;
            game.mode = 'playing';
            game.board = initializeBoard();
            game.currentPlayer = 'white';
            game.winner = null;
            game.aiThoughts = [];
            game.selectedPiece = null;
            game.validMoves = [];
            game.capturedPieces = { white: [], black: [] };
            game.lastMove = null;
            game.moveHistory = [];
            game.isInCheck = false;
            game.promotionDialog = null;
            updateDisplay();
        }

        function showAdvancedSettings() {
            const depth = prompt('Inserisci il numero di livelli di profondità per l\'IA (2-10):', '8');
            if (depth && !isNaN(depth)) {
                const depthNum = parseInt(depth);
                if (depthNum >= 2 && depthNum <= 10) {
                    startGame('custom', depthNum);
                } else {
                    alert('Inserisci un numero tra 2 e 10');
                }
            }
        }

        function resetGame() {
            game.mode = 'menu';
            updateDisplay();
        }

        // Rendering
        function updateDisplay() {
            const app = document.getElementById('app');
            
            if (game.mode === 'menu') {
                app.className = 'container show-menu';
                app.innerHTML = `
                    <div class="menu-container">
                        <h1>Scacchi</h1>
                        <p class="subtitle">by Dr. F.Marinuzzi</p>
                        <div>
                            <h2 class="difficulty-title">Seleziona Difficoltà</h2>
                            <button class="btn btn-easy" onclick="startGame('easy')">
                                <span>Facile</span>
                                <span>→</span>
                            </button>
                            <button class="btn btn-medium" onclick="startGame('medium')">
                                <span>Medio</span>
                                <span>→</span>
                            </button>
                            <button class="btn btn-hard" onclick="startGame('hard')">
                                <span>Difficile</span>
                                <span>→</span>
                            </button>
                            <button class="btn btn-custom" onclick="showAdvancedSettings()">
                                <span>Personalizzato</span>
                                <span>⚙️</span>
                            </button>
                        </div>
                    </div>
                `;
            } else {
                app.className = 'container show-game';
                app.innerHTML = `
                    <div class="game-container">
                        <div class="board-section">
                            <div class="game-header">
                                <div class="header-left">
                                    <h1 class="game-title">Scacchi</h1>
                                    ${game.mode === 'playing' ? `
                                        <button class="btn-surrender" onclick="surrenderGame()">
                                            🏳️ Abbandona
                                        </button>
                                    ` : ''}
                                </div>
                                <div class="players">
                                    <div class="player player-white ${game.currentPlayer === 'white' ? 'active' : 'inactive'}">
                                        👤 Il Tuo Turno
                                    </div>
                                    <div class="player player-black ${game.currentPlayer === 'black' ? 'active' : 'inactive'}">
                                        🤖 Turno IA
                                    </div>
                                </div>
                            </div>

                            ${game.isInCheck ? '<div class="check-alert">Scacco!</div>' : ''}

                            <div class="board">
                                <div class="board-grid">
                                    ${renderBoard()}
                                </div>
                            </div>

                            <div class="captured-pieces">
                                <div class="captured-section">
                                    <div class="captured-title" style="color: #93c5fd;">Pezzi Bianchi Catturati: ${game.capturedPieces.white.length}</div>
                                    <div class="captured-list">
                                        ${game.capturedPieces.white.map(piece => 
                                            `<span class="captured-piece">${PIECE_SYMBOLS[piece.color][piece.type]}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                                <div class="captured-section">
                                    <div class="captured-title" style="color: #d1d5db;">Pezzi Neri Catturati: ${game.capturedPieces.black.length}</div>
                                    <div class="captured-list">
                                        ${game.capturedPieces.black.map(piece => 
                                            `<span class="captured-piece">${PIECE_SYMBOLS[piece.color][piece.type]}</span>`
                                        ).join('')}
                                    </div>
                                </div>
                            </div>

                            ${game.mode === 'gameOver' ? `
                                <div class="game-over">
                                    <div class="game-over-title">
                                        ${game.winner === 'draw' ? 
                                            '<span class="draw-text">È un Pareggio!</span>' : 
                                            game.winner === 'white' ? 
                                                '<span class="win-text">Hai Vinto!</span>' : 
                                                '<span class="lose-text">L\'IA Ha Vinto!</span>'
                                        }
                                    </div>
                                    <button class="btn-reset" onclick="resetGame()">
                                        🔄 Gioca Ancora
                                    </button>
                                </div>
                            ` : ''}
                        </div>

                        <div class="ai-section">
                            <div class="ai-header">
                                <span>✨</span>
                                <span class="ai-title">Pensieri IA</span>
                                <span class="difficulty-badge">${game.difficulty === 'custom' ? `Personalizzato (${game.customDepth})` : game.difficulty}</span>
                            </div>
                            
                            <div class="ai-thoughts">
                                ${game.isAIThinking ? `
                                    <div class="ai-thinking">
                                        <div class="thinking-text">Analizzando la scacchiera...</div>
                                        <div class="progress-bar">
                                            <div class="progress-fill" style="width: 100%"></div>
                                        </div>
                                        <div class="progress-label">Analisi in corso...</div>
                                    </div>
                                ` : ''}
                                
                                ${game.aiThoughts.slice().reverse().map((thought, index) => `
                                    <div class="thought" style="opacity: ${index === 0 ? 1 : 0.7 - index * 0.1}">
                                        <div class="thought-text">${thought.text}</div>
                                        <div class="thought-meta">Mossa ${thought.round}</div>
                                    </div>
                                `).join('')}
                                
                                ${game.aiThoughts.length === 0 && !game.isAIThinking ? 
                                    '<div class="no-thoughts">I pensieri dell\'IA appariranno qui...</div>' : ''
                                }
                            </div>
                        </div>
                    </div>

                    ${game.promotionDialog ? `
                        <div class="promotion-dialog">
                            <div class="promotion-content">
                                <div class="promotion-title">Scegli il pezzo di promozione</div>
                                <div class="promotion-pieces">
                                    ${[PIECES.QUEEN, PIECES.ROOK, PIECES.BISHOP, PIECES.KNIGHT].map(pieceType => `
                                        <button class="promotion-btn" onclick="executePromotionMove('${pieceType}')">
                                            ${PIECE_SYMBOLS.white[pieceType]}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    ` : ''}
                `;
            }
        }

        function renderBoard() {
            let html = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isBlackSquare = (row + col) % 2 === 1;
                    const isSelected = game.selectedPiece?.row === row && game.selectedPiece?.col === col;
                    const isValidMove = game.validMoves.some(m => m.row === row && m.col === col);
                    const isLastMoveFrom = game.lastMove?.from.row === row && game.lastMove?.from.col === col;
                    const isLastMoveTo = game.lastMove?.to.row === row && game.lastMove?.to.col === col;
                    const isAnimating = game.animatingPieces.has(`${row}-${col}`);
                    const piece = game.board[row][col];
                    
                    let classes = ['square'];
                    classes.push(isBlackSquare ? 'dark' : 'light');
                    if (isSelected) classes.push('selected');
                    if (isValidMove) classes.push('valid-move');
                    if (isLastMoveFrom || isLastMoveTo) classes.push('last-move');
                    if (isAnimating) classes.push('animating');
                    
                    let pieceHtml = '';
                    if (piece) {
                        const pieceClass = piece.color === 'white' ? 'piece-white' : 'piece-black';
                        pieceHtml = `<span class="${pieceClass}">${PIECE_SYMBOLS[piece.color][piece.type]}</span>`;
                    }
                    
                    html += `
                        <div class="${classes.join(' ')}" onclick="handleSquareClick(${row}, ${col})">
                            ${pieceHtml}
                        </div>
                    `;
                }
            }
            
            return html;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateDisplay();
        });
    </script>
</body>
</html>
