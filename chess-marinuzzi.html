<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scacchi by Dr. F. Marinuzzi</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1e293b 0%, #1e3a8a 50%, #1e293b 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .menu {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 3rem;
            border-radius: 24px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 400px;
            width: 100%;
        }
        
        .game-container {
            display: flex;
            gap: 2rem;
            max-width: 1400px;
            width: 100%;
        }
        
        .board-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .ai-section {
            width: 350px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            padding: 1.5rem;
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            height: fit-content;
        }
        
        h1 {
            font-size: 3.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 1rem;
        }
        
        .subtitle {
            color: #d1d5db;
            margin-bottom: 2rem;
        }
        
        .difficulty-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        
        .btn {
            width: 100%;
            padding: 1rem 1.5rem;
            margin: 0.5rem 0;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .btn:hover {
            transform: scale(1.02);
        }
        
        .btn-easy {
            background: linear-gradient(45deg, #10b981, #059669);
            color: white;
        }
        
        .btn-medium {
            background: linear-gradient(45deg, #f59e0b, #ea580c);
            color: white;
        }
        
        .btn-hard {
            background: linear-gradient(45deg, #ef4444, #ec4899);
            color: white;
        }
        
        .btn-reset {
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 1rem;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .game-title {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .players {
            display: flex;
            gap: 1rem;
        }
        
        .player {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .player.active {
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }
        
        .player-white {
            background: linear-gradient(45deg, #dbeafe, #ffffff);
            color: #1e40af;
        }
        
        .player-black {
            background: linear-gradient(45deg, #374151, #111827);
            color: white;
        }
        
        .player.inactive {
            background: rgba(255, 255, 255, 0.1);
            color: #9ca3af;
        }
        
        .check-alert {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
            padding: 0.75rem;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        
        .board {
            background: #f3e8a6;
            padding: 1rem;
            border-radius: 16px;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        .board-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
        }
        
        .square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .square.light {
            background: #f3e8a6;
        }
        
        .square.dark {
            background: #b8860b;
        }
        
        .square:hover {
            brightness: 1.1;
        }
        
        .square.selected {
            box-shadow: inset 0 0 0 4px #3b82f6;
        }
        
        .square.valid-move {
            box-shadow: inset 0 0 0 2px #10b981;
        }
        
        .square.valid-move::before {
            content: '';
            position: absolute;
            inset: 8px;
            background: rgba(16, 185, 129, 0.3);
            border-radius: 50%;
        }
        
        .square.last-move {
            box-shadow: inset 0 0 0 4px #3b82f6;
            background: rgba(59, 130, 246, 0.3) !important;
            animation: pulse 1s infinite;
        }
        
        .square.animating {
            animation: bounce 0.3s ease;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .captured-pieces {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .captured-section {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            flex: 1;
        }
        
        .captured-title {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .captured-list {
            display: flex;
            gap: 0.25rem;
            flex-wrap: wrap;
        }
        
        .captured-piece {
            font-size: 1.125rem;
        }
        
        .promotion-dialog {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .promotion-content {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-align: center;
        }
        
        .promotion-title {
            color: #374151;
            font-size: 1.25rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        
        .promotion-pieces {
            display: flex;
            gap: 1rem;
        }
        
        .promotion-btn {
            width: 4rem;
            height: 4rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .promotion-btn:hover {
            background: #2563eb;
            transform: scale(1.05);
        }
        
        .game-over {
            text-align: center;
            margin-top: 1.5rem;
        }
        
        .game-over-title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 1rem;
        }
        
        .win-text {
            background: linear-gradient(45deg, #60a5fa, #ffffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .lose-text {
            background: linear-gradient(45deg, #9ca3af, #6b7280);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .draw-text {
            color: #fbbf24;
        }
        
        .ai-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .ai-title {
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .difficulty-badge {
            margin-left: auto;
            font-size: 0.875rem;
            color: #9ca3af;
            text-transform: capitalize;
        }
        
        .ai-thoughts {
            max-height: 600px;
            overflow-y: auto;
        }
        
        .ai-thinking {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        
        .thinking-text {
            color: #93c5fd;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(30, 58, 138, 0.5);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #60a5fa, #a855f7);
            animation: pulse 1s infinite;
        }
        
        .progress-label {
            font-size: 0.75rem;
            color: #93c5fd;
            margin-top: 0.25rem;
        }
        
        .thought {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            transition: all 0.3s;
        }
        
        .thought-text {
            color: #d1d5db;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }
        
        .thought-meta {
            color: #6b7280;
            font-size: 0.75rem;
        }
        
        .no-thoughts {
            color: #6b7280;
            text-align: center;
            padding: 2rem;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script>
        // Costanti del gioco
        const PIECES = {
            PAWN: 'pawn',
            ROOK: 'rook', 
            KNIGHT: 'knight',
            BISHOP: 'bishop',
            QUEEN: 'queen',
            KING: 'king'
        };

        const PIECE_VALUES = {
            [PIECES.PAWN]: 100,
            [PIECES.ROOK]: 500,
            [PIECES.KNIGHT]: 300,
            [PIECES.BISHOP]: 300,
            [PIECES.QUEEN]: 900,
            [PIECES.KING]: 10000
        };

        const PIECE_SYMBOLS = {
            white: {
                [PIECES.PAWN]: 'â™™',
                [PIECES.ROOK]: 'â™–',
                [PIECES.KNIGHT]: 'â™˜',
                [PIECES.BISHOP]: 'â™—',
                [PIECES.QUEEN]: 'â™•',
                [PIECES.KING]: 'â™”'
            },
            black: {
                [PIECES.PAWN]: 'â™Ÿ',
                [PIECES.ROOK]: 'â™œ',
                [PIECES.KNIGHT]: 'â™ž',
                [PIECES.BISHOP]: 'â™',
                [PIECES.QUEEN]: 'â™›',
                [PIECES.KING]: 'â™š'
            }
        };

        // Stato del gioco
        let gameState = {
            mode: 'menu', // 'menu', 'playing', 'gameOver'
            board: [],
            currentPlayer: 'white',
            winner: null,
            difficulty: 'medium',
            isAIThinking: false,
            aiThoughts: [],
            selectedPiece: null,
            validMoves: [],
            capturedPieces: { white: [], black: [] },
            lastMove: null,
            animatingPieces: new Set(),
            moveHistory: [],
            isInCheck: false,
            castlingRights: {
                whiteKingSide: true,
                whiteQueenSide: true,
                blackKingSide: true,
                blackQueenSide: true
            },
            promotionDialog: null
        };

        // Funzioni di utilitÃ 
        function initializeBoard() {
            const board = Array(8).fill().map(() => Array(8).fill(null));
            
            // Pedoni
            for (let col = 0; col < 8; col++) {
                board[1][col] = { type: PIECES.PAWN, color: 'black' };
                board[6][col] = { type: PIECES.PAWN, color: 'white' };
            }
            
            // Pezzi
            const backRank = [PIECES.ROOK, PIECES.KNIGHT, PIECES.BISHOP, PIECES.QUEEN, PIECES.KING, PIECES.BISHOP, PIECES.KNIGHT, PIECES.ROOK];
            for (let col = 0; col < 8; col++) {
                board[0][col] = { type: backRank[col], color: 'black' };
                board[7][col] = { type: backRank[col], color: 'white' };
            }
            
            return board;
        }

        function isValidPosition(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function findKing(board, color) {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.type === PIECES.KING && piece.color === color) {
                        return { row, col };
                    }
                }
            }
            return null;
        }

        function isKingInCheck(board, color) {
            const kingPos = findKing(board, color);
            if (!kingPos) return false;
            
            const enemyColor = color === 'white' ? 'black' : 'white';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === enemyColor) {
                        const moves = getPieceMoves(board, row, col, piece, false);
                        if (moves.some(move => move.row === kingPos.row && move.col === kingPos.col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getPawnMoves(board, row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            
            // Movimento in avanti
            const newRow = row + direction;
            if (isValidPosition(newRow, col) && !board[newRow][col]) {
                moves.push({ row: newRow, col });
                
                // Doppio movimento dalla posizione iniziale
                if (row === startRow && !board[newRow + direction][col]) {
                    moves.push({ row: newRow + direction, col });
                }
            }
            
            // Catture diagonali
            for (const dc of [-1, 1]) {
                const captureRow = row + direction;
                const captureCol = col + dc;
                if (isValidPosition(captureRow, captureCol)) {
                    const target = board[captureRow][captureCol];
                    if (target && target.color !== color) {
                        moves.push({ row: captureRow, col: captureCol });
                    }
                }
            }
            
            return moves;
        }

        function getRookMoves(board, row, col, color) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            
            for (const [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            return moves;
        }

        function getKnightMoves(board, row, col, color) {
            const moves = [];
            const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
            
            for (const [dr, dc] of knightMoves) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isValidPosition(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            return moves;
        }

        function getBishopMoves(board, row, col, color) {
            const moves = [];
            const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dr, dc] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + dr * i;
                    const newCol = col + dc * i;
                    
                    if (!isValidPosition(newRow, newCol)) break;
                    
                    const target = board[newRow][newCol];
                    if (!target) {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (target.color !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                }
            }
            return moves;
        }

        function getQueenMoves(board, row, col, color) {
            return [...getRookMoves(board, row, col, color), ...getBishopMoves(board, row, col, color)];
        }

        function getKingMoves(board, row, col, color) {
            const moves = [];
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            // Mosse normali
            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                
                if (isValidPosition(newRow, newCol)) {
                    const target = board[newRow][newCol];
                    if (!target || target.color !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }
            
            // Arrocco
            const kingRow = color === 'white' ? 7 : 0;
            
            if (row === kingRow && col === 4) {
                // Arrocco corto
                if (gameState.castlingRights[color === 'white' ? 'whiteKingSide' : 'blackKingSide']) {
                    if (!board[kingRow][5] && !board[kingRow][6] && 
                        board[kingRow][7] && board[kingRow][7].type === PIECES.ROOK && 
                        board[kingRow][7].color === color) {
                        moves.push({ row: kingRow, col: 6, isCastling: true, castlingType: 'kingside' });
                    }
                }
                
                // Arrocco lungo
                if (gameState.castlingRights[color === 'white' ? 'whiteQueenSide' : 'blackQueenSide']) {
                    if (!board[kingRow][1] && !board[kingRow][2] && !board[kingRow][3] && 
                        board[kingRow][0] && board[kingRow][0].type === PIECES.ROOK && 
                        board[kingRow][0].color === color) {
                        moves.push({ row: kingRow, col: 2, isCastling: true, castlingType: 'queenside' });
                    }
                }
            }
            
            return moves;
        }

        function getPieceMoves(board, row, col, piece, checkForCheck = true) {
            if (!piece) return [];
            
            let moves = [];
            
            switch (piece.type) {
                case PIECES.PAWN:
                    moves = getPawnMoves(board, row, col, piece.color);
                    break;
                case PIECES.ROOK:
                    moves = getRookMoves(board, row, col, piece.color);
                    break;
                case PIECES.KNIGHT:
                    moves = getKnightMoves(board, row, col, piece.color);
                    break;
                case PIECES.BISHOP:
                    moves = getBishopMoves(board, row, col, piece.color);
                    break;
                case PIECES.QUEEN:
                    moves = getQueenMoves(board, row, col, piece.color);
                    break;
                case PIECES.KING:
                    moves = getKingMoves(board, row, col, piece.color);
                    break;
            }
            
            if (checkForCheck) {
                moves = moves.filter(move => {
                    const testBoard = simulateMove(board, row, col, move.row, move.col);
                    return !isKingInCheck(testBoard, piece.color);
                });
            }
            
            return moves;
        }

        function simulateMove(board, fromRow, fromCol, toRow, toCol) {
            const newBoard = board.map(row => [...row]);
            const piece = newBoard[fromRow][fromCol];
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;
            return newBoard;
        }

        function executeMove(board, fromRow, fromCol, toRow, toCol, moveInfo = null) {
            const newBoard = board.map(row => [...row]);
            const piece = newBoard[fromRow][fromCol];
            const capturedPiece = newBoard[toRow][toCol];
            
            // Mossa base
            newBoard[toRow][toCol] = piece;
            newBoard[fromRow][fromCol] = null;
            
            // Arrocco
            if (moveInfo && moveInfo.isCastling) {
                const rookRow = toRow;
                if (moveInfo.castlingType === 'kingside') {
                    const rook = newBoard[rookRow][7];
                    newBoard[rookRow][5] = rook;
                    newBoard[rookRow][7] = null;
                } else if (moveInfo.castlingType === 'queenside') {
                    const rook = newBoard[rookRow][0];
                    newBoard[rookRow][3] = rook;
                    newBoard[rookRow][0] = null;
                }
            }
            
            // Promozione
            if (piece.type === PIECES.PAWN) {
                const promotionRow = piece.color === 'white' ? 0 : 7;
                if (toRow === promotionRow) {
                    const promotionPiece = moveInfo?.promotionPiece || PIECES.QUEEN;
                    newBoard[toRow][toCol] = { type: promotionPiece, color: piece.color };
                }
            }
            
            // Aggiorna diritti di arrocco
            const newCastlingRights = { ...gameState.castlingRights };
            
            if (piece.type === PIECES.KING) {
                if (piece.color === 'white') {
                    newCastlingRights.whiteKingSide = false;
                    newCastlingRights.whiteQueenSide = false;
                } else {
                    newCastlingRights.blackKingSide = false;
                    newCastlingRights.blackQueenSide = false;
                }
            }
            
            if (piece.type === PIECES.ROOK) {
                if (piece.color === 'white') {
                    if (fromRow === 7 && fromCol === 0) newCastlingRights.whiteQueenSide = false;
                    if (fromRow === 7 && fromCol === 7) newCastlingRights.whiteKingSide = false;
                } else {
                    if (fromRow === 0 && fromCol === 0) newCastlingRights.blackQueenSide = false;
                    if (fromRow === 0 && fromCol === 7) newCastlingRights.blackKingSide = false;
                }
            }
            
            return { newBoard, capturedPiece, newCastlingRights };
        }

        function getAllValidMoves(board, color) {
            const moves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && piece.color === color) {
                        const pieceMoves = getPieceMoves(board, row, col, piece);
                        for (const move of pieceMoves) {
                            moves.push({
                                fromRow: row,
                                fromCol: col,
                                toRow: move.row,
                                toCol: move.col,
                                piece,
                                isCastling: move.isCastling,
                                castlingType: move.castlingType
                            });
                        }
                    }
                }
            }
            return moves;
        }

        function evaluatePosition(board) {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        let pieceValue = PIECE_VALUES[piece.type];
                        
                        if (piece.type === PIECES.PAWN) {
                            if (piece.color === 'white') {
                                pieceValue += (6 - row) * 10;
                            } else {
                                pieceValue += (row - 1) * 10;
                            }
                        }
                        
                        const centerDistance = Math.abs(3.5 - row) + Math.abs(3.5 - col);
                        pieceValue += (7 - centerDistance) * 5;
                        
                        if (piece.color === 'black') {
                            score += pieceValue;
                        } else {
                            score -= pieceValue;
                        }
                    }
                }
            }
            
            if (isKingInCheck(board, 'black')) score -= 500;
            if (isKingInCheck(board, 'white')) score += 500;
            
            return score;
        }

        function alphaBeta(board, depth, alpha, beta, maximizingPlayer, color) {
            if (depth === 0) {
                return { score: evaluatePosition(board), move: null };
            }
            
            const moves = getAllValidMoves(board, color);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, color)) {
                    return { score: maximizingPlayer ? -10000 : 10000, move: null };
                } else {
                    return { score: 0, move: null };
                }
            }
            
            let bestMove = null;
            
            if (maximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const { newBoard } = executeMove(board, move.fromRow, move.fromCol, move.toRow, move.toCol, move);
                    const evaluation = alphaBeta(newBoard, depth - 1, alpha, beta, false, 'white');
                    
                    if (evaluation.score > maxEval) {
                        maxEval = evaluation.score;
                        bestMove = move;
                    }
                    
                    alpha = Math.max(alpha, evaluation.score);
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const { newBoard } = executeMove(board, move.fromRow, move.fromCol, move.toRow, move.toCol, move);
                    const evaluation = alphaBeta(newBoard, depth - 1, alpha, beta, true, 'black');
                    
                    if (evaluation.score < minEval) {
                        minEval = evaluation.score;
                        bestMove = move;
                    }
                    
                    beta = Math.min(beta, evaluation.score);
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        function findBestMove(board, depth) {
            const result = alphaBeta(board, depth, -Infinity, Infinity, true, 'black');
            return result.move;
        }

        function checkGameEnd(board, color) {
            const moves = getAllValidMoves(board, color);
            
            if (moves.length === 0) {
                if (isKingInCheck(board, color)) {
                    return color === 'white' ? 'black' : 'white';
                } else {
                    return 'draw';
                }
            }
            return null;
        }

        // Eventi del gioco
        function handleSquareClick(row, col) {
            if (gameState.mode !== 'playing' || gameState.currentPlayer !== 'white' || gameState.isAIThinking) return;
            
            const piece = gameState.board[row][col];
            
            if (gameState.selectedPiece) {
                const validMove = gameState.validMoves.find(m => m.row === row && m.col === col);
                
                if (validMove) {
                    const movingPiece = gameState.board[gameState.selectedPiece.row][gameState.selectedPiece.col];
                    const isPromotion = movingPiece && movingPiece.type === PIECES.PAWN && 
                                       movingPiece.color === 'white' && row === 0;
                    
                    if (isPromotion) {
                        gameState.promotionDialog = {
                            fromRow: gameState.selectedPiece.row,
                            fromCol: gameState.selectedPiece.col,
                            toRow: row,
                            toCol: col,
                            validMove
                        };
                        updateDisplay();
                        return;
                    }
                    
                    makeMove(gameState.selectedPiece.row, gameState.selectedPiece.col, row, col, validMove);
                } else {
                    selectPiece(row, col, piece);
                }
            } else {
                selectPiece(row, col, piece);
            }
        }

        function selectPiece(row, col, piece) {
            if (!piece || piece.color !== gameState.currentPlayer) {
                gameState.selectedPiece = null;
                gameState.validMoves = [];
                updateDisplay();
                return;
            }
            
            const moves = getPieceMoves(gameState.board, row, col, piece);
            gameState.selectedPiece = { row, col };
            gameState.validMoves = moves;
            updateDisplay();
        }

        function makeMove(fromRow, fromCol, toRow, toCol, moveInfo, promotionPiece = null) {
            const moveInfoWithPromotion = promotionPiece ? { ...moveInfo, promotionPiece } : moveInfo;
            
            const { newBoard, capturedPiece, newCastlingRights } = executeMove(
                gameState.board, fromRow, fromCol, toRow, toCol, moveInfoWithPromotion
            );
            
            const pieceId = `${fromRow}-${fromCol}`;
            gameState.animatingPieces.add(pieceId);
            
            gameState.board = newBoard;
            gameState.lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
            gameState.castlingRights = newCastlingRights;
            
            if (capturedPiece) {
                if (gameState.currentPlayer === 'white') {
                    gameState.capturedPieces.black.push(capturedPiece);
                } else {
                    gameState.capturedPieces.white.push(capturedPiece);
                }
            }
            
            setTimeout(() => {
                gameState.animatingPieces.delete(pieceId);
                updateDisplay();
            }, 300);
            
            const nextPlayer = gameState.currentPlayer === 'white' ? 'black' : 'white';
            gameState.isInCheck = isKingInCheck(newBoard, nextPlayer);
            
            const gameEnd = checkGameEnd(newBoard, nextPlayer);
            if (gameEnd) {
                gameState.winner = gameEnd;
                gameState.mode = 'gameOver';
            } else {
                gameState.currentPlayer = nextPlayer;
            }
            
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.promotionDialog = null;
            
            updateDisplay();
            
            // IA move
            if (gameState.currentPlayer === 'black' && gameState.mode === 'playing') {
                setTimeout(makeAIMove, 500);
            }
        }

        async function makeAIMove() {
            gameState.isAIThinking = true;
            gameState.aiThoughts = [];
            updateDisplay();

            await new Promise(resolve => setTimeout(resolve, 500));

            try {
                gameState.aiThoughts.push({
                    text: "Analizzando tutte le mosse possibili...",
                    round: Math.floor(gameState.moveHistory.length / 2)
                });
                updateDisplay();

                await new Promise(resolve => setTimeout(resolve, 300));

                let searchDepth;
                switch (gameState.difficulty) {
                    case 'easy': searchDepth = 2; break;
                    case 'medium': searchDepth = 4; break;
                    case 'hard': searchDepth = 6; break;
                    default: searchDepth = 4;
                }

                gameState.aiThoughts.push({
                    text: `Analisi a ${searchDepth} livelli di profonditÃ ...`,
                    round: Math.floor(gameState.moveHistory.length / 2)
                });
                updateDisplay();

                const startTime = Date.now();
                const bestMove = findBestMove(gameState.board, searchDepth);
                const endTime = Date.now();

                if (!bestMove) {
                    gameState.winner = 'white';
                    gameState.mode = 'gameOver';
                    updateDisplay();
                    return;
                }

                gameState.aiThoughts.push({
                    text: `Mossa trovata in ${((endTime - startTime) / 1000).toFixed(1)}s`,
                    round: Math.floor(gameState.moveHistory.length / 2)
                });
                updateDisplay();

                await new Promise(resolve => setTimeout(resolve, 300));

                makeMove(bestMove.fromRow, bestMove.fromCol, bestMove.toRow, bestMove.toCol, 
                        { ...bestMove, promotionPiece: PIECES.QUEEN });

            } catch (error) {
                console.error('AI Error:', error);
                gameState.currentPlayer = 'white';
                updateDisplay();
            } finally {
                gameState.isAIThinking = false;
                updateDisplay();
            }
        }

        function executePromotionMove(pieceType) {
            const dialog = gameState.promotionDialog;
            makeMove(dialog.fromRow, dialog.fromCol, dialog.toRow, dialog.toCol, dialog.validMove, pieceType);
        }

        function startGame(difficulty) {
            gameState.difficulty = difficulty;
            gameState.mode = 'playing';
            gameState.board = initializeBoard();
            gameState.currentPlayer = 'white';
            gameState.winner = null;
            gameState.aiThoughts = [];
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.capturedPieces = { white: [], black: [] };
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.isInCheck = false;
            gameState.promotionDialog = null;
            gameState.castlingRights = {
                whiteKingSide: true,
                whiteQueenSide: true,
                blackKingSide: true,
                blackQueenSide: true
            };
            updateDisplay();
        }

        function resetGame() {
            gameState.mode = 'menu';
            gameState.board = [];
            gameState.currentPlayer = 'white';
            gameState.winner = null;
            gameState.aiThoughts = [];
            gameState.selectedPiece = null;
            gameState.validMoves = [];
            gameState.capturedPieces = { white: [], black: [] };
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.isInCheck = false;
            gameState.promotionDialog = null;
            gameState.castlingRights = {
                whiteKingSide: true,
                whiteQueenSide: true,
                blackKingSide: true,
                blackQueenSide: true
            };
            updateDisplay();
        }

        // Rendering
        function updateDisplay() {
            const app = document.getElementById('app');
            
            if (gameState.mode === 'menu') {
                app.innerHTML = `
                    <div class="container">
                        <div class="menu">
                            <h1>Scacchi</h1>
                            <p class="subtitle">by Dr. F.Marinuzzi</p>
                            <div>
                                <h2 class="difficulty-title">Seleziona DifficoltÃ </h2>
                                <button class="btn btn-easy" onclick="startGame('easy')">
                                    <span>Facile</span>
                                    <span>â†’</span>
                                </button>
                                <button class="btn btn-medium" onclick="startGame('medium')">
                                    <span>Medio</span>
                                    <span>â†’</span>
                                </button>
                                <button class="btn btn-hard" onclick="startGame('hard')">
                                    <span>Difficile</span>
                                    <span>â†’</span>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                app.innerHTML = `
                    <div class="container">
                        <div class="game-container">
                            <div class="board-section">
                                <div class="game-header">
                                    <h1 class="game-title">Scacchi</h1>
                                    <div class="players">
                                        <div class="player player-white ${gameState.currentPlayer === 'white' ? 'active' : 'inactive'}">
                                            ðŸ‘¤ Il Tuo Turno
                                        </div>
                                        <div class="player player-black ${gameState.currentPlayer === 'black' ? 'active' : 'inactive'}">
                                            ðŸ¤– Turno IA
                                        </div>
                                    </div>
                                </div>

                                ${gameState.isInCheck ? '<div class="check-alert">Scacco!</div>' : ''}

                                <div class="board">
                                    <div class="board-grid">
                                        ${renderBoard()}
                                    </div>
                                </div>

                                <div class="captured-pieces">
                                    <div class="captured-section">
                                        <div class="captured-title" style="color: #93c5fd;">Pezzi Bianchi Catturati: ${gameState.capturedPieces.white.length}</div>
                                        <div class="captured-list">
                                            ${gameState.capturedPieces.white.map(piece => 
                                                `<span class="captured-piece">${PIECE_SYMBOLS[piece.color][piece.type]}</span>`
                                            ).join('')}
                                        </div>
                                    </div>
                                    <div class="captured-section">
                                        <div class="captured-title" style="color: #d1d5db;">Pezzi Neri Catturati: ${gameState.capturedPieces.black.length}</div>
                                        <div class="captured-list">
                                            ${gameState.capturedPieces.black.map(piece => 
                                                `<span class="captured-piece">${PIECE_SYMBOLS[piece.color][piece.type]}</span>`
                                            ).join('')}
                                        </div>
                                    </div>
                                </div>

                                ${gameState.mode === 'gameOver' ? `
                                    <div class="game-over">
                                        <div class="game-over-title">
                                            ${gameState.winner === 'draw' ? 
                                                '<span class="draw-text">Ãˆ un Pareggio!</span>' : 
                                                gameState.winner === 'white' ? 
                                                    '<span class="win-text">Hai Vinto!</span>' : 
                                                    '<span class="lose-text">L\'IA Ha Vinto!</span>'
                                            }
                                        </div>
                                        <button class="btn-reset" onclick="resetGame()">
                                            ðŸ”„ Gioca Ancora
                                        </button>
                                    </div>
                                ` : ''}
                            </div>

                            <div class="ai-section">
                                <div class="ai-header">
                                    <span>âœ¨</span>
                                    <span class="ai-title">Pensieri IA</span>
                                    <span class="difficulty-badge">${gameState.difficulty}</span>
                                </div>
                                
                                <div class="ai-thoughts">
                                    ${gameState.isAIThinking ? `
                                        <div class="ai-thinking">
                                            <div class="thinking-text">Analizzando la scacchiera...</div>
                                            <div class="progress-bar">
                                                <div class="progress-fill" style="width: 100%"></div>
                                            </div>
                                            <div class="progress-label">Analisi in corso...</div>
                                        </div>
                                    ` : ''}
                                    
                                    ${gameState.aiThoughts.slice().reverse().map((thought, index) => `
                                        <div class="thought" style="opacity: ${index === 0 ? 1 : 0.7 - index * 0.1}">
                                            <div class="thought-text">${thought.text}</div>
                                            <div class="thought-meta">Mossa ${thought.round}</div>
                                        </div>
                                    `).join('')}
                                    
                                    ${gameState.aiThoughts.length === 0 && !gameState.isAIThinking ? 
                                        '<div class="no-thoughts">I pensieri dell\'IA appariranno qui...</div>' : ''
                                    }
                                </div>
                            </div>
                        </div>
                    </div>

                    ${gameState.promotionDialog ? `
                        <div class="promotion-dialog">
                            <div class="promotion-content">
                                <div class="promotion-title">Scegli il pezzo di promozione</div>
                                <div class="promotion-pieces">
                                    ${[PIECES.QUEEN, PIECES.ROOK, PIECES.BISHOP, PIECES.KNIGHT].map(pieceType => `
                                        <button class="promotion-btn" onclick="executePromotionMove('${pieceType}')">
                                            ${PIECE_SYMBOLS.white[pieceType]}
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                    ` : ''}
                `;
            }
        }

        function renderBoard() {
            let html = '';
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const isBlackSquare = (row + col) % 2 === 1;
                    const isSelected = gameState.selectedPiece?.row === row && gameState.selectedPiece?.col === col;
                    const isValidMove = gameState.validMoves.some(m => m.row === row && m.col === col);
                    const isLastMoveFrom = gameState.lastMove?.from.row === row && gameState.lastMove?.from.col === col;
                    const isLastMoveTo = gameState.lastMove?.to.row === row && gameState.lastMove?.to.col === col;
                    const isAnimating = gameState.animatingPieces.has(`${row}-${col}`);
                    const piece = gameState.board[row][col];
                    
                    let classes = ['square'];
                    classes.push(isBlackSquare ? 'dark' : 'light');
                    if (isSelected) classes.push('selected');
                    if (isValidMove) classes.push('valid-move');
                    if (isLastMoveFrom || isLastMoveTo) classes.push('last-move');
                    if (isAnimating) classes.push('animating');
                    
                    html += `
                        <div class="${classes.join(' ')}" onclick="handleSquareClick(${row}, ${col})">
                            ${piece ? PIECE_SYMBOLS[piece.color][piece.type] : ''}
                        </div>
                    `;
                }
            }
            
            return html;
        }

        // Avvio
        updateDisplay();
    </script>
</body>
</html>